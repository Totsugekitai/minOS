# Red Zone で苦しんだ話

セキュリティキャンプで自作OSにコンソール関数を実装したのだが、その際に出会った不可解なバグとその原因について記す。

## 当時の状況

自作OSへのタイマ割り込みとコンソール関数は実装済みで、コンソール関数で使えるコマンドを増やすというテーマでセキュリティキャンプに参加した。
いくつかコマンドを作ってみて、よしよしいいペースだと思いながら実行してみると、なんだか例外が出て動作が終了してしまう。
デバッグしてみると、デバッグ用の無限ループ部で止まるときと、それをすり抜けて不正なアドレスへ飛んでいるときの2種類のパターンがあることがわかり、タイミングもまちまちだったので悩んでいた。

## 原因は Red Zone だった

苦しんでいると講師のhikaliumさんが「それ Red Zone とかじゃない？」とおっしゃった。試しにコンパイルオプションに -mno-red-zone と Red Zone なるものを無効化するものを追加してみると、なんと正常に動くではないか。

Red Zone というものがまずかったらしい。

## Red Zone とは

Red Zone とはコンパイラが行う最適化の一種である。
関数の末尾で計算を行うとき、後ろに関数呼び出しがない場合は rsp の値を変えずに rsp から -128 bytes 分のスタック領域を用いることによって、変数の確保を楽にしよう、という手法である。
これは通常のユーザプログラムなら正常に動作するし、何も考えずにコンパイラに任せればよいのだが、 Red Zone 使用中に割込みが入ると途端にバグの温床となる。

順番に説明すると、次のようになる。

1. 関数の実行中に Red Zone を用いて計算する
2. 1の途中に割込みが入ると、 Red Zone の領域に割込みハンドラの情報がおかれる
3. 割込みから復帰し、 Red Zone を用いた計算を再開させようとすると、割込みハンドラで上書きされたスタックを読むことになり、計算結果がおかしくなる

(ここに図を入れる)

したがって、OS開発時には Red Zone を disable にしてやる必要がある。気を付けよう。


# タスク切り替え時のスタックで苦しんだ話

タスク切り替えをどのタイミングでどのようにやるかというのはいくつかバリエーションがある。

前提を整理しておくと、タスク切り替えでやらなくてはいけない処理というのは次の通り。

    1. 現在のタスクのレジスタを保存する
    2. スタックポインタを次のタスクのものに切り替える
    3. 次のタスクのレジスタをロードする
    4. プログラムカウンタを次のタスクのものに切り替える

自分は最初は

    1. タスク切り替えの時間をタイマ割り込みハンドラで見る(ここで割り込み開始)
    2. 時間が過ぎたことをハンドラで検知したらハンドラの中でスケジューラを呼び出す
    3. スケジューラの中でタスク切り替え処理を呼び出す
    4. タスク切り替えの処理
        1. 現在のレジスタを現在のタスクに割り当てられたスタックに積む
        2. 現在のスタックポインタを保存し、次のタスクのスタックポインタをロードする
        3. 次のタスクのレジスタをロード
        4. iretq 命令で次のタスクのプログラムカウンタをロード(ここで割り込み終了)

となるように実装していた。

ここで問題となるのは iretq 命令だ。
iretq 命令はスタックを5つぶん pop し、5つのそれぞれの値を特殊なレジスタたちに書き込んでいく命令であり、その中にプログラムカウンタの rip も含まれる。
つまり iretq 命令を発行する前にはスタックを調整してやる必要があるのだが、スタックの調整がややこしく、何度書き直しても思った通りのアドレスに到達しないという症状が出た。
これを2週間くらいデバッグしたが、結局正しいスタック調整ができなかった。

(後で図を追加する)

詰まっていたところ大学の指導教官からアドバイスをいただき、次のようにプログラムを書き直した。

    1. タスク切り替えの時間をタイマ割り込みハンドラで見る(ここで割り込み開始)
    2. 時間が過ぎたことをハンドラで検知したらハンドラの中でスケジューラを呼び出す
    3. スケジューラの中でタスク切り替え処理を呼び出す
    4. タスク切り替えの処理
        1. 現在のレジスタを現在のタスクに割り当てられたスタックに積む
        2. 現在のスタックポインタを保存し、次のタスクのスタックポインタをロードする
        3. 次のタスクのレジスタをロード
        4. ret 命令で割り込みハンドラに戻る
        5. 割り込みハンドラの終了処理が走る(ここで割り込み終了)
        6. 次のタスクのレジスタとスタックポインタがよみこまれているので次のタスクが走る

プログラムカウンタはどうなったと思うだろうが大丈夫である。
というのも、割り込みハンドラが呼ばれる直前に、CPUがその時点でのプログラムカウンタをスタックに積んでくれるからである。
つまりスタックは以下のような挙動をする。

    1. タスクaのプログラムカウンタが push される( CPU によって自動)
        -- ここまで割り込みハンドラの中 --
        -- ここからスケジューラ関数 --
    2. タスクaの汎用レジスタを push する(自分のプログラム)
    3. (スタックポインタが切り替えられる)
    4. タスクbの汎用レジスタが pop される(自分のプログラム)
        -- ここまでスケジューラ関数の中 --
        -- ここから割込みハンドラに復帰 --
    5. (割込みハンドラの末尾に到達)
    6. タスクbのプログラムカウンタが pop される( CPU によって自動)

(後で図を追加する)

このようにすることによって、スタックの扱いがシンプルになり面倒な帳尻合わせがいらなくなった。