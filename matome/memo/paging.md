# paging

## paging modes and bits

以下のコントロールビットで制御される。

- CR0.WP(bit 16) と CR0.PG(bit 31)
- CR4 の PSE(bit 4), PAE(bit 5), PGE(bit 7), PCIDE(bit 17), SMEP(bit 20), SMAP(bit 21), PKE(bit 22)
- IA32_EFER MSR の LME(bit 8), NXE(bit 11)
- EFLAGS の AC(bit 18)

MOV命令をCR0に用いてCR0.PGを設定する。その前に、CR3に最初のページング構造の物理アドレスをふくめなければならないし、それを初期化しなければならない(Table4-7, 4-12)。

### three paging modes

CR0.PG: ページングのON,OFF
CR0.PE: プロテクションのON,OFF
CR4.PAE, IA32_EFER.LME: ページングモードの切り替え
    - CR0.PG = 1, CR4.PAE = 1, IA32_EFER.LME = 1 で4-level paging

ページングモードの違い
- リニアアドレスのサイズ
- 物理アドレスのサイズ
- ページのサイズ
- アクセス権限のサポート
- PCIDsのサポート
- プロテクションキーのサポート
    - 4-level では、リニアアドレスをプロテクションキーに関連付けるための機能を有効にできる

IA32_EFER.LMA = 1: IA-32eモードになる。直接設定不可。IA32_EFERに対してwrmsrしてもbit 10は無視される。

64-bit mode: 64-bitリニアアドレス。プロセッサはアドレスのbit 63:47 が同一であることを確認する。4-levelではbit 63:48は使用されない。

### paging mode enabling

以下の順番でビットを立てると4-levelのページングになる。

1. CR4.PAE = 1
2. IA32_EFER.LME = 1
3. CR0.PG = 1

- IA32_EFER.LMEはページングが有効になっている間は変更できない。wrmsrしたら#GP(0)が発生する。
- ページングモードにかかわらず、CR0.PGを下げるとページングが切れる。

### paging-mode modifiers

ページングモードは以下のビットで制御される。

- CR0.WP(bit 16)
    - スーパーバイザモードからの書き込みからページを保護するかどうか
    - WP = 0: スーパーバイザモードからの書き込みはread onlyのリニアアドレスに対して許可される
    - WP = 1: ユーザーモードからの書き込みはread onlyのリニアアドレスに対して許可されない
    - Section 4.6を見よ。
- CR4 の PSE(bit 4), PAE(bit 5), PGE(bit 7), PCIDE(bit 17), SMEP(bit 20), SMAP(bit 21), PKE(bit 22)
    - PSE: 32bit pagingで4MBのページサイズ
    - PGE: global pageの有無。
        - Section 4.10.2.4
    - PCIDE: process-context identifiers(PCIDs)
        - 4-levelの時は1にしておく
        - 論理プロセッサに対してリニアアドレスの計算の情報をキャッシュする。
        - Section 4.10.1
    - SMEP: スーパーバイザモードからの命令フェッチからのページの保護。
        - これが立っているとユーザーモードでアクセスできるリニアアドレスから、OSは命令をフェッチできなくなる
        - Section 4.6
    - SMAP: スーパーバイザモードからのデータアクセスからのページの保護。
        - 立てるとユーザーモードでアクセスできるデータにOSはアクセスできなくなる。
        - EFLAGS.ACを設定することによって上書きできる。
        - Section 4.6
    - PKE: リニアアドレスとプロテクションキーを関連付ける。
        - PKPUレジスタでそれぞれのプロテクションキーに対してリニアアドレスが読み書きできるか指定する。
        - Section 4.6
- IA32_EFER.NXE(bit 11)
    - NXE: 4-levelにおいてアクセス権限の実行と無効化を決める。
        - 立てると命令フェッチが指定されたリニアアドレスからされたふりをする（データの読み込みが許可されている場合）
        - Section 4.6

### emuration of paging features by cpuid

CPUID命令を使ったページングの疑似命令がつかえる。
4-levelページングに関係あるもののみまとめる。

- PAE: physical-address extension
    - CPUID.01H:EDX.PAE[bit 6] = 1の時、CR4.PAEを1にセットするとPAEページングモードになる。
- PGE: global-page support
    - CPUID.01H:EDX.PGE[bit 13] = 1の時、CR4.PGEを1にセットすると、global-pageが有効になる。
    - Section 4.10.2.4
- PAT: page-attribute table
    - CPUID.01H:EDX.PAT[bit 16] = 1の時、8-entry page-attribute table(PAT)が有効になる。
    - PATが有効の時、特定のページ構造エントリの3つのビットがメモリタイプをPATから選ぶ。
    - Section 4.9.2
- PSE-36: page-size extensions with 40-bit physical-address extension
    - CPUID.01H:ECX.PSE-36[bit 17] = 1のとき、PSE-36機構が有効になる。
    - 4MBのページを用いた変換を32-bitページングで物理アドレスが40-bitまで対応する。
- PCID: process-context identifiers
    - CPUID.01H:ECX.PCID[bit 17] = 1のときCR4.PCIDE = 1にすると、process-context identifiersが有効になる。
    - Section 4.10.1

## hierarchical paging structures: an overview

全てのページング構造は階層的。4-levelページングに関係あるもののみまとめる。
4-levelの詳細はSection 4.5にある。

全てのページング構造は4096bytesで、多数の個別のエントリを含む。
4-levelページングでは、エントリは64bits(8bytes)で、512エントリをそれぞれのデータ構造が保持している。

プロセッサはリニアアドレスの上位部分を用いてページング構造のエントリを特定する。
エントリの最後はリニアアドレスの変換先となる領域の物理アドレスを識別する。(page frameと呼ぶ)
リニアアドレスの下位部分は(page offsetと呼ぶ)、リニアアドレスの変換先となる、特定のアドレスを識別する。

どのページング構造でも、物理アドレスを含み、それは他のページング構造のアドレスとなっているか、もしくはページフレームのアドレスとなっている。
最初の例として、エントリは他のページング構造の"参照"と呼ばれ、その他は"ページマップ"と呼ばれる。

色々な変換に使われる最初のページング構造は、CR3レジスタ内部に物理アドレスで存在する。
リニアアドレスは次の段階的なプロシージャを用いて変換される。
リニアアドレスのある部分(初期は最も上位を占める)は、ページングエントリを選択する(CR3レジスタを用いて配置される)。

以下は例である(4KBページフレーム)。4-levelの例のみ記す。

それぞれのページング構造は512 = 2^9エントリから構成され、48bitリニアアドレスから変換には9bitが用いられる。
bits47:39は最初のページング構造を識別するのに使われ、bits38:30は2つ目のページング構造、bits29:21は3つ目、bits20:12は4つ目である。また、残りはページフレームを識別するのに使われる(Figure 4-8)。

変換プロセスはページフレームを識別して完了する。
ページフレームはオリジナルのリニアアドレスの変換の一部である。
しかし、一部のケースで、ページング構造は変更されることもあるので、変換プロセスはページフレームを識別してから行わなくてはならない。
これはプロセスが出くわした、ページング構造のエントリが、"not present"(P flag)かどうかを確認しなくてはならない。
P flagが0のときはリニアアドレスの変換は行われず、アドレスへのアクセスはpage-fault例外を引き起こす(Section 4.7)。

上の例で、あるページング構造のエントリがリニアアドレスに12bitしか残っていない場合に、pageを4KBのpageにマップする。以前に識別されたエントリは常に他のページング構造を参照する。

■ページングモード別のページング構造

- PML4
    - Entry name: PML4E
    - Physical address of structure: CR3
    - bits selecting entry: 47:39
    - page mapping: N/A(PS must be 1)
- PDP
    - entry name: PDPTE
    - physical address of structure: PML4E
    - bits selecting entry: 38:30
    - 1GB page if PS = 1
- PD
    - entry name: PDE
    - physical address of structure: PDPTE
    - bits selecting entry: 29:21
    - page mapping: 2MB page if PS = 1
- PT
    - entry name: PTE
    - physical address of structure: PDE
    - bits selecting entry: 20:12
    - page mapping: 4KB page

## 4-level paging

CR0.PG = 1, CR4.PAE = 1, IA32_EFER.LME = 1で論理プロセッサは4-levelページングになる。
CR3レジスタを用いてメモリ上に配置されたページング構造階層を用いてリニアアドレスが変換される。
48-bitリニアアドレスを52-bit物理アドレスに変換する。
256TBのリニアアドレスまで理論上はアクセスできる。

4-levelページングはリニアアドレスの変換を生成するページング構造階層(PML4)を用いる。
4-levelページングでのCR3レジスタの使用はPCIDsがCR4.PCIDEによって設定されているかどうかによる。

CR4.PCIDE = 1の場合:

    - PCID(bit 11:0)
    - Physical address of the 4KB aligned PML4 table used for linear-address translation(bit M-1:12)
    - Reserved(must be 0)(bit 63:M)

Section 4.10.4.1でCR3レジスタに渡すソースオペランドの63bitの使い方を説明している。
CR4.PCIDEを修正した後、論理プロセッサはすぐにCR3レジスタを指定通りに使い始める。
例: CR4.PCIDEを1から0に変更すると、現在のPCIDはすぐにCR3[11:0]から000Hに変更される。加えて、論理プロセッサはPCIDのbit 4:3のCR3.PCDやCR3.PWTを用いているPML4にアクセスするメモリタイプを特定する。

4-levelページングはリニアアドレスを4KB,2MB,1GBのページにマップする。
以下が2MBのページ機構の図である。

![図](pictures/translation_to_2MB_page.png)

CR4.PKE = 1のとき、4-levelページングは各リニアアドレスとprotection keyを関連付ける。
Section 4.6でプロセッサがprotection keyを用いて各リニアアドレスのアクセス権を特定する方法を説明している。

- 4KBにアラインメントされるPML4テーブルはCR3の51:14bitで特定される物理アドレスに配置される。PML4テーブルは64-bitのエントリが512個から構成される(PML4Es)。PML4Eは以下で定義される物理アドレスを用いて選ばれる。
  
    - 51:12bitはCR3から定義される
    - 11:3bitはリニアアドレスの47:39bitで定義される
    - 2:0bitは0である

リニアアドレスの47:39bitを用いてPML4Eは識別されるので、PML4Eはリニアアドレス空間の512GBの領域のアクセスをコントロールできる。

- 4KBにアラインメントされるPDPテーブルはPML4Eの51:12bitで特定される物理アドレスに配置される。PDPテーブルｈｓ64-bitのエントリが512個から構成される(PDPTEs)。PDPTEは以下で定義される物理アドレスを用いて選ばれる。

    - 51:12bitはPML4Eから定義される
    - 11:3bitはリニアアドレスの38:30から定義される
    - 2:0bitは0である

リニアアドレスの47:30bitを用いてPDPTEは識別されるので、PDPTEはリニアアドレス空間の1GBの領域のアクセスをコントロールできる。PDPTEの使用はPSフラグに依存する。

- PDPTEのPSフラグが1のとき、PDPTEは1GBのページをマップする。最終的な物理アドレスは以下で算出される。

    - 51:30bitはPDPTEから定義される
    - 29:0bitはもとのリニアアドレスから定義される

CR4.PKE = 1のとき、リニアアドレスのprotection keyはPDPTEの62:59bitの値である。

- PDPTEのPSフラグが0のとき、4KBでアラインメントされたページディレクトリはPDPTEの51:12bitで表された物理アドレスに配置される。ページディレクトリは64-bitのエントリが512個から構成される(PDEs)。PDEは以下で定義される物理アドレスを用いて選ばれる。

    - 51:12bitはPDPTEから定義される
    - 11:3bitはリニアアドレスの29:21bitで定義される
    - 2:0は0である

リニアアドレスの47:21bitを用いてPDEは識別されるので、リニアアドレス空間の2MBの領域のアクセスをコントロールできる。PDEの使用はPSフラグに依存する。

- PDEのPSフラグが1のとき、PDEは2MBのページをマップする。最終的な物理アドレスは以下で算出される。

    - 51:21bitはPDEから定義される
    - 20:0bitはもとのリニアアドレスから定義される

CR4.PKE = 1のとき、リニアアドレスのprotection keyはPDEの62:59bitの値である。

- PDEのPSフラグが0のとき、4KBにアラインメントされたページテーブルはPDEの51:12bitで指定される物理アドレスに配置される。ページテーブルは64-bitのエントリが512個から構成される(PTEs)。PTEは以下で定義される物理アドレスを用いて選ばれる。

    - 51:12bitはPDEから定義される
    - 11:3bitはリニアアドレスの20:12bitから定義される
    - 2:0bitは0である

- PTEはリニアアドレスの47:12bitを用いて識別されるので、全てのPTEは4KBページをマップする。最終的な物理アドレスは以下で算出される。

    - 51:12bitはPTEから定義される
    - 11:0bitはもとのリニアアドレスから定義される

CR4.PKE = 1のとき、リニアアドレスのprotection keyはPTEの62:59bitの値である。

## access rights

ここでは上で述べた処理が完了し、物理アドレスを生成し終わった際の、リニアアドレスの変換について述べる。
変換によってアクセスが許可されているかどうかは、ページング構造のエントリで記述されるアクセス権限によって決められる。
具体的にはページングモードを変更するCR0, CR4, IA32_EFER, EFLAGS.AC、それとアクセスのモードである。
ここでは4-levelページングで、かつCR4.PKE = 1のときを想定する。

### determination of access rights

全てのリニアアドレスへのアクセスは、スーパーバイザーモードかユーザーモードかで行う。
全ての命令フェッチとデータアクセスにおいて、CPL(current privilege level)によってこの区別は決められる。
アクセスはCPL < 3でスーパーバイザーモード、CPL = 3でユーザーモードである。

いくつかの命令は暗黙的にシステムのデータ構造にリニアアドレスでアクセスする。
これらのデータ構造はCPLに関係なくスーパーバイザーモードでアクセスされる。
例:

- GDTやLDTにアクセスしてセグメントディスクリプタをロードする
- IDTにアクセスして割り込みや例外を伝達する
- TSSにアクセスしてCPLを変更する作業をする

これらは全て暗黙的にCPLに関係なくスーパーバイザーモードでアクセスが行われる。
他のCPL < 3のアクセスは明示的にスーパーバイザーモードで行う。

アクセス権限はリニアアドレスのモードでもコントロールされ、モードはページング構造のエントリで特徴づけられる。
最低でも一つのページング構造のエントリのU/Sフラグ(bit 2)が0だと、アドレスはスーパーバイザーモードのアドレスである。該当しない場合はユーザーモードのアドレスである。

以下はページングにおいてのアクセス権限の決め方である。

- スーパーバイザーモードのアクセス
    - データがスーパーバイザーモードでreadされる
    - データがユーザーモードのページからreadする(CR4.SMAPで権限が決まる)
        - CR4.SMAP = 0: データはアクセス許可のprotection keyがついた任意のユーザーモードアドレスからreadされる
        - CR4.SMAP = 1: アクセス権限はEFLAGS.ACの値と、アクセスが暗黙的か明示的かによって決まる
            - EFLAGS.AC = 1かつ明示的: データはアクセス許可のprotection keyがついた任意のユーザーモードアドレスからreadされる
            - EFLAGS.AC = 0または暗黙的: データはどのユーザーモードアドレスからもreadされない

            Section 4.6.2でprotection keyとユーザーモードアドレスとの関連付けと、各protection keyでのアクセス許可を説明している
    - データをスーパーバイザーモードアドレスにwriteする(CR4.WPで権限が決まる)
        - CR4.WP = 0: データはスーパーバイザーモードアドレスにwriteされる
        - CR4.WP = 1: データは全てのページング構造のR/Wフラグが1のときに行われる変換によるスーパーバイザーモードアドレスにwriteされる。R/Wフラグが0のときはwriteされない
    - データをユーザーモードアドレスにwriteする(CR4.WPで権限が決まる)
        - CR0.WP = 0: アクセス権限はCR4.SMAPの値によって決まる
            - CR4.SMAP = 0: writeアクセスが許可されたprotection keyが付与されたユーザーモードアドレスにデータはwriteされる
            - CR4.SMAP = 1: アクセス権限はEFLAGS.ACの値と、アクセスが明示的か暗黙的かによって決まる
                - EFLAGS.AC = 1かつアクセスが明示的: writeアクセスが許可されたprotection keyが付与されたユーザーモードアドレスにデータはwriteされる
                - EFLAGS.AC = 0またはアクセスが暗黙的: どのユーザーモードアドレスにもwriteできない
        - CR0.WP = 1: アクセス権限はCR4.SMAPの値で決まる
            - CR4.SMAP = 0: ページ変換を制御する全てのページング構造のエントリでR/Wフラグが1で、アクセスが許可されたprotection keyが付与されたユーザーモードアドレスにデータはwriteされる。R/Wフラグが0だとデータはwriteされない
            - CR4.SMAP = 1: アクセス権限はEFLAGS.ACの値とアクセスが明示的か暗黙的かによって決まる
                - EFLAGS.AC = 1かつアクセスが明示的: ページ変換を制御する全てのページング構造のエントリでR/Wフラグが1で、アクセスが許可されたprotection keyが付与されたユーザーモードアドレスにデータはwriteされる。R/Wフラグが0のときはwriteできない
                - EFLAGS.AC = 0またはアクセスが暗黙的: ユーザーモードアドレスにはwriteできない
                Section 4.6.2でprotection keyのユーザーモードアドレスとの関連付け方と、各protection keyに許可されたアクセスを説明する
    - スーパーバイザーモードアドレスからの命令フェッチ
        - IA32_EFER.NXE = 1かつ4-levelページング: 変換に使われる全てのページング構造エントリのR/Wフラグが1のときに行われる変換によるスーパーバイザーモードアドレスから命令がフェッチされる
    - ユーザーモードアドレスからの命令フェッチ(CR4.SMEPの値で権限が決まる)
        - CR4.SNEP = 0: IA32_EFER.NXEの値でアクセス権限が決まる
            - 4-levelページングかつIA32_EFER.NXE = 1: 変換を制御する全てのページング構造のXDフラグが0のユーザーモードアドレスの変換で命令フェッチがされる。XDフラグが1だとユーザーモードアドレスから命令フェッチできない
        - CR4.SNEP - 1: ユーザーモードアドレスから命令フェッチできない
- ユーザーモードアクセス:
    - データのreadはリニアアドレスのモードに左右される
        - 変換を制御する全ページング構造エントリのR/Wフラグが1かつreadアクセスが許可されているprotection keyの変換でユーザーモードアドレスにデータがreadされる。Section 4.6.2で詳細に説明。
        - どのスーパーバイザーモードアドレスもreadはできない
    - データのwriteはリニアアドレスのモードに左右される
        - 変換を制御する全ページング構造エントリのR/Wフラグが1かつwriteアクセスが許可されているprotection keyの変換でユーザーモードアドレスにデータがwriteされる。Section 4.6.2で詳細に説明。
        - どのスーパーバイザーモードアドレスでもwriteできない
    - 命令フェッチのアクセス権限はリニアアドレスのモード、ページングのモード、IA32_EFER.NXEの値で決まる。
        - 4-levelページングかつIA32_EFER.NXE = 1のとき、変換を制御するページング構造エントリのR/Wフラグが1で変換を行うことで命令がフェッチされる。
        - スーパーバイザーモードアドレスは命令フェッチできない

プロセッサはページング構造エントリの情報をTLBやページングキャッシュにキャッシュする(Section 4.10)。
ページング構造エントリはアクセス権に関する情報も含んでいる。
プロセッサはメモリ上のページング構造のアクセス権限よりも、キャッシュ上のアクセス権限を優先するように強制する。

この事実は、ソフトウェアがページング構造エントリを修正してアクセス権限を変えたとしても、プロセッサはそれを使わずにその後のリニアアドレスを処理することを意味する。
Section 4.10.4.2を見て、ソフトウェアがどのように修正後のリニアアドレスを用いるか調べよ。

### protection keys

CR4.PKE = 1のとき、全てのリニアアドレスは4-bitのprotection keyに関連付けられ、それはページング構造エントリの62:59bitに位置する。
PKPUレジスタでそれぞれのプロテクションキーに対してユーザーモードアドレスが読み書きできるか指定する。

CR4.PKE = 0または4-levelページングが非アクティブのとき、プロセッサはリニアアドレスとprotection keyを関連付けないし、このSectionで記述されたアクセス制御メカニズムを使用しない。

どちらの場合においても、ユーザーモードアドレスへのprotection keyを用いた参照は、任意のユーザーモードアドレスへの参照を考慮しなくてはならない。

PKPUレジスタ(protection key rights for user pages)は32-bitの以下のようなフォーマットである。

0 ≦ i ≦ 15の各iにおいて、PKPU[2i]はprotection key iに対するaccess-disableビット(ADi)である。
PKPU[2i+1]はprotection key iに対するwrite-disableビット(WDi)である。

ソフトウェアはECX = 0で、RDPKPU,WRPKPU命令によってPKPUレジスタをread,writeできる。
加えて、PKPUレジスタはXSAVE-managed stateであり、よってXSAVEの命令でread,writeできる。
ココらへんはSDM vol.1 Chapter 13を参照すべし。

どのようにリニアアドレスのprotection keyがアクセス制御を行っているかはリニアアドレスのモードに依存する。

- リニアアドレスのprotection keyはデータアクセスのみを制御する。命令フェッチには影響を及ぼさない\
- スーパーバイザーモードアドレスのprotection keyは無視され、かつアクセス制御は行われない。これによって、スーパーバイザーモードアドレスへのアクセス権限を指定する時、Section 4.6.1はprotection keyを指し示さなくなる。
- ユーザーモードアドレスにおけるprotection key iの使用は、PKPUレジスタの値によって決まる。
    - ADi = 1: データアクセスは禁止される
    - WDi = 1: 特定のデータに対するwriteアクセスは拒否される
        - ユーザーモードでのwriteアクセスは禁止される
        - スーパーバイザーモードでのwriteアクセスはCR0.WP = 1で拒否、CR0.WP = 0だとWDiはスーパーバイザーモードでのユーザーモードアドレスへのwriteアクセスへ影響を及ぼさない。

## page-fault exceptions

リニアアドレスを用いたアクセスはpage-fault exceptions(#PF)を引き起こすことがある。
理由は2つあり、
    1. リニアアドレスの変換が行われていない
    2. リニアアドレスの変換は行われているが、アクセス権限がない
である。
ページング構造エントリのPフラグ(bit 0)が0もしくは予約ビットに値をセットした場合には変換は行われない。
変換が行われる時、アクセス権限が指定されるのは先のセクションで述べたとおり。

Intel SGXが有効の時、プロセッサはexception 14を、ページングに関連付けられていないという理由で発行するときがある。
Section 37.3ではこの例外をSGX-induced page faultとよんでいる。

以下の図はプロセッサがページフォルトを起こすときに発行されるエラーコードである。

![図](pictures/page-fault_error_code.png)

各ビットの詳細はSDM参照。

page-fault exceptionsはリニアアドレスを用いようと試みたときのみ起こる。

## accessed and dirty flags

リニアアドレス変換をおこなうページング構造エントリでは、bit 5はaccessedフラグである。
別のページング構造を参照するのではなく、ページのマップを行うページング構造エントリでは、bit 6はdirtyフラグである。
これらのフラグはメモリマネジメントソフトウェアを用いてページや物理メモリの内外の変換を行うために提供される。

プロセッサがリニアアドレスの変換の一部としてページング構造エントリを用いているときは常に、そのエントリではaccessedフラグが立っている(既に立っていなかったら)。

リニアアドレスへのwriteがあるときは常に、プロセッサはリニアアドレスから最終的な物理アドレスを決めるページング構造エントリにおいて、dirtyフラグを立てる(既に立っていなかったら)(PTEかページング構造エントリのPSフラグが1である)。

ページもしくはページング構造が物理メモリからイニシャライズされてロードされる時、メモリマネジメントソフトウェアはこれらのフラグをクリアする。
これらのフラグは"sticky"(一度立てたらプロセッサはクリアせず、ソフトウェアがクリアする必要があるという意味)である。

プロセッサはページング構造エントリの情報をTLBやページングキャッシュにキャッシュする。
これはもしソフトウェアがaccessedフラグやdirtyフラグを1から0に変更したら、プロセッサはメモリ上の、リニアアドレスを用いたその後のアクセスに対応したビットをセットできない可能性がある。
Section 4.10.4.2でソフトウェアが満たすべきビットの更新仕様を確認せよ。

## paging and memory typing

メモリアクセスにおけるmemory typeはアクセスに用いられるキャッシュのタイプである。
Chapter 11が詳しい。

プロセッサがPage Attribute Table(PAT Section 11.12)に対応しているかどうかにページングのmemory typingへの作用は依存する。

### when the PAT is supported

PATがサポートされている時、ページングはPATとmemory-type range registers(MTRRs)と組み合わせて、Section 11.5.2.2のように、memory typingに作用する。

PATは64-bit MSRで(IA32_PAT; MSR index 277H)、8bitのエントリを含んでいる(entry iはMSRのbit 8i+7:8iを含む)。

どんな物理アドレスへのアクセスでも、テーブルは、MTRRsによって決められた物理アドレスから特徴づけられるmemory typeと、PATから選ばれたmemory typeを組み合わせる。
特に、それはPATのエントリのi由来であり、iは以下のように定められる。

- PML4テーブルのエントリへのアクセスにおけるCR3レジスタは以下の通り
    - 4-levelページングでCR4.PCIDE = 1のとき、i = 0
    - それ以外では、i = 2************×PCD+PWTで、PCDとPWTはCR3からのものである。
- 他のページング構造エントリYにアドレスがある、ページング構造エントリXへのアドレスにおいては、i = 2×PCD+PWTであり、PCDとPWTはYからのものである。
- リニアアドレスを変換して得られる物理アドレスにアクセスする際は、i = 4×PAT+2×PCD+PWTである。PAT,PCD,PWTの値は、ページサイズが4MBはPDE由来である。

### caching paging-related infomation about memory typing

プロセッサはページング構造エントリをTLBやページングキャッシュにキャッシュする。
これらの構造はmemory typingの情報を含むことがある。
プロセッサはキャッシュを優先して読み込む。

つまりメモリ上のページング構造エントリのmemory typeのビットを変えても、キャッシュを優先的に読み込むため、リニアアドレスの変換に適用されない可能性がある。
Section 4.10.4.2を見よ。

## caching translation infomation

### process-context identifiers(PCIDs)

PCIDsは、論理プロセッサがリニアアドレス空間の計算のための情報をキャッシュする機関である。
ソフトウェアが異なるPCIDを用いてリニアアドレス空間をスイッチした際に、プロセッサはキャッシュ情報を保持する。

PCIDは12ビットの識別子である。
Non-zero PCIDはCR4レジスタのPCIDEフラグ(bit 17)を設定すると使用可能になる。
CR4.PCIDE = 0のとき、現在のPCIDは常に000Hである。
他の状況では、現在のPCIDはCR3レジスタの11:0bitの値である。
全てのプロセッサでCR4.PCIDE = 1が許可されているわけではない(Section 4.1.4)。

プロセッサがCR4.PCIDE = 1を許すのはIA-32eモードのときのみである。
加えて、ソフトウェアがCR4.PCIDEを0から1に変更ができるのは、CR3[11:0] = 000Hのときである。
満たすべき仕様は以下のとおりである。

- IA32_EFER.LMA = 0 or CR3[11:0] != 000HでCR4.PCIDEを0から1に変更すると、#GPが発生する
- CR4.PCIDE = 1のときCR0.PGをクリアして0にすると、#GPが発生する

論理プロセッサがキャッシュにエントリを生成する時、エントリは現在のPCIDに関連付けられる。
キャッシュのエントリを用いてリニアアドレスの変換を行う時、論理プロセッサは現在のPCIDに関連のあるキャッシュのエントリのみを用いる(例外がSection 4.10.2.4にある)。

CR4.PCIDE = 0のとき、論理プロセッサは000H以外のPCIDに関連付けられた情報をキャッシュしない。

### translation lookaside buffers(TLBs)

プロセッサはリニアアドレス変換の情報をTLBにキャッシュする時がある。
一般に、TLBsはページナンバーをページフレームにマップするエントリを含む。

#### page numbers, page frames, and page offsets

リニアアドレスの上位のビット(page numberと呼ぶ)は物理アドレスの上位ビットを決定する(page frameと呼ぶ)。
リニアアドレスの下位のビット(page offsetと呼ぶ)は物理アドレスの下位ビットを決定する。
page numberとpage offsetの境界はpage sizeで決定される。
4-levelページングでの境界は以下の通り。

- PDEを変換に使わないとき(PDPTEを使用中のときはPSフラグが1という理由のため)、page sizeは1GBでかつpage numberはリニアアドレスの47:30bitを含む
- PDEを変換に使っているがPTEを使っていないとき(PDEを使用中のときはPSフラグが1という理由のため)、page sizeは2MBかつpage numberはリニアアドレスの47:21bitを含む
- PTEを変換に使用しているとき、page sizeは4KBかつpage numberはリニアアドレスの47:12bitを含む

#### caching translation in TLBs

TLBの各エントリは独立した変換を行う。
各変換はpage numberによって参照される。
リニアアドレスの変換に使われるページング構造エントリから得られた情報をTLBは含む。

- page number, page frameに対応した物理アドレス
- page numberを用いてリニアアドレスを変換するページング構造エントリのアクセス権限
    - R/Wフラグの論理積
    - U/Sフラグの論理積
    - XDフラグの論理和(IA32_EFER.NXE = 1のときのみ必要)
    - protection key(4-levelページングかつCR4.PKE = 1のときのみ必要)
- page numberのために最終的なpage frameを決めるページング構造エントリから得られた属性(PTE = 1かページング構造エントリのPSフラグが1)
    - dirtyフラグ
    - memory type

TLBエントリは他の情報も含むことが有る。
プロセッサはTLBを複数実装することもある、またそれらのうちいくつかは特別な用途に、例えば命令フェッチに用いられたりする。
特別な用途のTLBは、必要なければ先のような情報は含まない。
例えば、命令フェッチにのみ使われるTLBはR/Wフラグやdirtyフラグの情報を含まない。

Section 4.10.1で論理プロセッサによって生成されるTLBは現在のPCIDと関連付けられることが述べられている。

プロセッサはTLBを、本質的には必要としない。
TLBを実装したプロセッサは、時にはTLBを無効化するかもしれない。
ソフトウェアはTLBの存在やTLBエントリの保持に頼るべきではない。

#### details of TLB use

## using for virtual memory

ページングを用いる際、リニアアドレス空間の一部分は物理アドレス空間にマップする必要はない。
マップされないアドレスへと送られるデータはディスクなどの外部に保存されるかもしれない。
リニアアドレス空間のマッピング方法はvirtual memoryかdemand-paged virtual memoryという用語で表される。

ページングはリニアアドレス空間を、サイズが補正されて物理アドレス空間にマップできるいわゆるページと、かつ/または外部ストレージに分割する。
プログラムやタスクがリニアアドレス空間を参照した時、プロセッサはページングを用いてリニアアドレスを変換し、もしそのアドレスが定義されていたら対応する物理アドレスにする。

リニアアドレスを含むページが実際に物理アドレス空間にマップされなかったときは、プロセッサは#PFを発生させる。
ページフォルト例外のハンドラは、通常はマッピングされていないページのデータを外部から物理メモリにロードし(プロセスで物理メモリから外部に異なるページを書き込む)、ページング構造を更新してそれを用いてマッピングする。
ページが物理アドレスからロードされた時は、例外ハンドラの戻り値はリスタートを行う例外を起こす。

ページングはセグメンテーションとは違い、固定サイズのページを用いる。
セグメントはコードやデータ構造で同じサイズであるが、ページは固定サイズである。
セグメンテーションがアドレス変換の唯一の手段のときは、物理メモリに存在するデータ構造はメモリにそれらの全てを保持するだろう。
ページングを用いる時、データ構造はメモリ上やディスク上で分割されている。



