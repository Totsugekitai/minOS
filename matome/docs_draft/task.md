# タスク機能の実現について

このページは自作OSにどうやってタスク概念を作り、マルチタスクを実装するか記述するページです。

## タスクとはなんだろうか

Intel SDM によると、

> A task is a unit of work that a processor can dispatch, execute, and suspend. (Chapter 7 Task Management より)

と記述されている。
つまり、開始して、実行して、終了する、1つの処理の単位のこと。
処理の単位って何のことだと思うが、これは実行中の1つのプログラムだと思うことにする。
実行中の1つのプログラムなのだから、当然実行中のプログラム、つまりタスクごとにスタックも保持している。

例を出そう。
例えばブラウザを開きながらテキストエディタでコーディングし、コンソールでコマンドを動かしている状況では、タスクは

    - ブラウザ
    - テキストエディタ
    - コンソール

の3つである。
もう1つ例を挙げると、何か時間がかかる計算(円周率の計算とか)を裏で動かしつつ、さらに別の計算(深層学習とか)をさせる状況では、タスクは

    - 円周率の計算
    - 深層学習

の2つである。

このように、私たちがコンピュータを利用する際には、複数のタスクを同時に実行することがほとんどである。
しかしCPUが1つの場合、CPUが一度にできる処理はアセンブリ命令1つなので、単純に複数の処理を同時に実行させることはできない。

じゃあ普通のOSではどうしているかというと、複数のタスクを高速で切り替えることによって、疑似的に複数のタスクが動いているように見せかけているのだ。これをマルチタスクという。

## マルチタスクの実現に必要な要件

自分のOSにもマルチタスクを実現したい。そのために必要なことをまとめる。

### まずはマルチタスクの処理を知る

マルチタスクをする際の処理の流れは以下のようになる。
ここではタスクAとタスクBが存在するとする。

1. タスクAの処理を開始させる
2. 時間が経ったり条件が満たされるとスケジューラが呼ばれる
3. タスクAの状態を保存する
4. タスクBの前回の状態を復帰させる
5. タスクBの処理を開始させる
6. 時間が経ったり条件が満たされるとスケジューラが呼ばれる
7. タスクBの状態を保存する
8. タスクAの前回の状態を復帰させる
9. 1に戻る

これを考えてみると、まずタスクは切り替わる際に直前の状態を保存する必要がありそうだ。
ほかにもスケジューラと呼ばれる、次にどのタスクを実行するか選出を行う処理が必要そうである。

### タスクに必要な情報

ここでタスクとは実行中の1つのプログラムと冒頭で述べたことを思い出そう。
実行中のプログラムがその瞬間瞬間で覚えていることは以下の3つである。

- 計算に使われる汎用レジスタの値
- スタックの位置を記憶するスタックポインタ
- プログラムがどこまで実行されたかを記憶するプログラムカウンタ

この3つさえあれば、プログラムが中断されてもその直前の状態を復帰できる。つまりタスクは最低限この3つの情報を覚えておけばよさそうだ。

これらの値をどこに保存するのがよいだろうか。

汎用レジスタについては、task構造体を定義して構造体のフィールドに格納してもよいのだが、汎用レジスタは十数個あるので少し面倒だし、それにアセンブラで構造体を扱いたくない。
そこでスタックを用いよう。汎用レジスタをスタックにポンポン push していって、復帰させるときにはポンポン pop させることにする。ただし push と pop は順番が重要なので注意する。

スタックポインタもスタックに記憶しようか。しかしスタックポインタは push や pop をするたびに値が書き換わるため、これを push すると少々考え事が増えそうである。これはtask構造体の中にしまってしまおう。

プログラムカウンタはどうしようかと悩んだが、割込みハンドラの中でタスクの交換をやると仮定すると考えなくてもよくなる。
というのも、割込みハンドラは呼び出される直前にその時のプログラムカウンタを暗黙的にスタックに push しているからだ。割込みハンドラが保存をやってくれているので、私たちが考えるのはプログラムカウンタの復帰についてのみである。

### スケジューラについて

とりあえず1つのタスクを実行させる制限時間を定めて、時間が来たらタスクを切り替えるという感じにしよう。