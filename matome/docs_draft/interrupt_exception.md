# 割り込みについて

割り込みとは、現在行っている処理を一時中断して別の処理を行い、それが終わったら前の処理を再開させるといった一連の流れを言う。

割り込み信号をCPUが受け取ると、現在行っている処理を中断し、割り込みハンドラと呼ばれる処理が開始される。
割り込みハンドラの処理が終了すると、行っていた処理の続きから復帰して処理を再開させる。

## 割り込みベクタについて

プロセッサによる特別な処理を必要とする割り込みには、ベクタ番号と呼ばれる識別番号が割り当てられる。
このベクタ番号は、割り込み記述子テーブル(Interrupt Descriptor Table)のインデックスとして用いられる。

ベクタ番号の範囲は0から255まで。
0から31まではアーキテクチャで定められた割り込みや例外のハンドラを登録する。
アーキテクチャで定められていない番号も存在するが、その場合は使ってはいけない。

32から255まではOS開発者が自由に割り込みハンドラを登録してよいベクタ番号である。
一般的には外部のIOデバイスのために用いられる。

## 外部割込み

外部からの割り込みはCPUのピンもしくはlocal APICと呼ばれるコントローラを通じて受け取られる。
現代のCPUにおいて、プライマリなピンはLINT[1:0]ピンであり、これはlocal APICに接続されている。
local APICが有効な時、LINT[1:0]ピンはAPICのlocal vector table(LVT)を通じてプログラムできる。

local APICが無効な時は、これらのピンはINTRとNMIピンとして設定される。

## ソフトウェア割込み

`INT n` 命令はソフトウェア内部で割り込みを発生させる。
RFLAGS レジスタの IF フラグではマスクできない。

## Interrupt Descriptor Table(IDT)

IDTは割り込みハンドラを登録するテーブルである。
テーブルの先頭を割り込みベクタ0とし、配列の形で定義してやるとよい。
具体的には以下のようにやるとよいかも。

```
typedef void (*interrupt_handler)(void);
interrupt_handler IDT[256] = {NULL};

IDT[0] = handler0;
IDT[1] = handler1;
IDT[2] = handler2;
IDT[3] = handler3;
.
.
.

```

このテーブルの先頭アドレスを IDTR と呼ばれるレジスタに登録し lidt 命令を発行するとテーブルがロードされ、IDTに登録したハンドラが使われるようになる。

## Intel 8259 PICについて

Intel 8259はレガシーな割り込みコントローラである。
Master PICとSlave PICという2つのコントローラをセットで用いて、15個の割り込みを制御できる。

### Command port と Data port

masterとslaveにはそれぞれcommand portとdata portと呼ばれるI/O portが存在する。
それぞれ次の通りである。

|chip          |port  |
|--------------|:----:|
|Master-command|0x20  |
|Master-Data   |0x21  |
|Slave-command |0xA0  |
|Slave-data    |0xA1  |

### IRQ

MasterのIRQは0-7、SlaveのIRQは8-15であるが、Masterのベクタオフセットが0x08から始まるので、割り込みベクタの番号が0x08-0x0Fとなってしまう。
Intelのアーキテクチャでは0x00-0x1FがCPUの例外のために予約されているので、これはコンフリクトしてしまう。

コンフリクトを回避するために、ベクタオフセットをずらす手法がとられる。
具体的にはMasterのオフセットを0x20に、Slaveのオフセットを0x28にずらして対応する。
