# GDT初期化

ここではGDTの初期化について解説します。

## GDTとは

Global (Segment) Descriptor Tableの略称。

OSのメモリ管理においてセグメンテーションという方式があります。
物理メモリをセグメントと呼ばれる単位に切り分けて管理する方法で、そのセグメントを管理するためのテーブルがGDT。

x86_64ではメモリ管理にはセグメンテーションは使われておらず、代わりにページングと呼ばれるメモリ管理方式を用いてメモリを管理しています。
ならいらないかというとそうでもなく、CPUの仕様でセグメンテーションを無効にできないため、初期化作業はいまだに必要です。
またプロテクションレベルを切り替えるためにも用いるため、意外と侮れません。

## セグメンテーションに関連するレジスタ群

- CS, SS, DS, ES, FS, GS
    - セグメントレジスタと呼ばれるレジスタたち。16bit長。
    - GDTにおいては、テーブルの何番目を指すのか、権限レベルはどうなのかといったことを指定するために用いる。
    - 64-bitモードでは扱うのは実質CSのみ
- GDTR
    - GDTのベースアドレスとリミットを指定するレジスタ。64bitモードでは79bit長。

## 64-bitモードのセグメンテーションのフロー

以下の図がx64のメモリ管理の概観です。

![segmentation and paging](./images/segmentation_and_paging.png)

ページングと一緒になっているのでややこしいですが、ここではセグメンテーションの部分だけ見ます。

### 論理アドレスからリニアアドレスへの変換方法

まず論理アドレスが与えられると、CPUはセグメントレジスタにセットされているセグメントセレクタを見て、GDTの何番目のディスクリプタを見るかを確認します。

次に、指定されたディスクリプタを見て、セグメントがリニアアドレスのどこから始まっているのか、つまりセグメントのベースアドレスを確認します。

そして、論理アドレスはそのセグメントのオフセットとして見られるので、論理アドレスとリニアアドレスの対応は、

```
リニアアドレス = 論理アドレス + セグメントのベースアドレス
```

となります。

### 具体例

論理アドレスが0x00010000で、現在のセグメントレジスタにセットされているセグメントセレクタのindexが1、GDTの1番目のディスクリプタが表すベースアドレスが0x30000000とする。

この時、まずセグメントセレクタのindexが1なので、GDTの1番目のディスクリプタを見る。GDTの1番目のディスクリプタには0x30000000がベースアドレスとしてセットされているので、ここを基準に見る。

与えられた論理アドレス0x00010000をオフセットとして見るので、上の計算式に当てはめてみると、

```
リニアアドレス = 0x00010000 + 0x30000000
			　= 0x30010000
```

となり、リニアアドレスは0x30010000と分かる。

### GDT 

まずGDTですが、これは以下のようなビット列が連なったテーブルです。

![segment descriptor](./images/segment_descriptor.png)

重要なのはBaseとSegment Limitです。
セグメンテーションではメモリをセグメントという単位で分割します。
Baseというのはそのセグメントが開始するアドレスです。
一方Segment Limitというのはそのセグメントの長さです。
例えば、Base = 0x7c00, Segment Limit = 0x100とすると、そのセグメントは0x7c00 ～ 0x7d00の範囲です。

その他のパラメータの設定はとりあえずLinuxのをまねることにします。以下設定。

- DとL: D = 0, L = 1で64-bitモードで動作するコードセグメントを表す。
- AVL: OS用のフラグ。Linuxでは0。
- DPL: セグメントへのアクセスに必要な特権レベルを表す。カーネルランドなので0を指定しておく。
- G: limitの単位を表す。0 = byte, 1 = page(4KB)
- P: セグメントがメモリ上に存在するときは1、存在しないときは0に設定する。Linuxでは常に1。
- S: セグメントディスクリプタは1に設定。
- Type: セグメントのタイプを設定する。色々あるが、実行と読み出し可能なコードセグメントの場合は5を設定し、読み書き可能なデータセグメントの場合は1を設定する。

x64ではセグメンテーションが使われていないと書きました。
これはセグメントの指定を、メモリ全体を指すように設定することで実質無効化します。
また、Segment Limitは64-bitモードでは無視されます。
つまり、Base = 0にCPUが強制することによって、メモリ全体を包むセグメントを作り、セグメントではメモリを区切らない(1つに区切るともいえる)ようにしています。

上の図ですべての要素が0のディスクリプタをNull Descriptorといいます。
GDTの先頭はNull DescriptorにしておくようにSDMには書いてあります。

またセグメントにはプロテクションレベルを設定することができます。

私たちが最低限用意すべきディスクリプタは以下の3つです。

1. Null Descriptor
2. コードセグメントを表す権限0のディスクリプタ
3. データセグメントを表す権限0のディスクリプタ

コードセグメントとデータセグメントの2つが必要な理由としては、読み出しと書き込みと実行をひとつのディスクリプタで設定することはできないことがあげられます。
今やりたいことはメモリ上のデータの読み書き実行ですが、権限のフラグを見ると、読み出しと書き込みと実行をひとつのディスクリプタで設定することはできないことが確認できます。
3つのことをできるように設定しようとすると、ディスクリプタが2つになってしまうのである。

### セグメントセレクタ

セグメントセレクタとは、16bitのセグメント識別子です。
このデータ構造をセグメントレジスタにセットして、現在のセグメントを定義するセグメントディスクリプタを指定します。
この章の最初の図を見るとわかりやすいです。

セグメントレジスタですが、64-bitモードではCSにセグメントセレクタをセットしてセグメントディスクリプタを指定します。
CS以外は無効化あるいは0として扱われるので気にしなくても大丈夫です。

CSですが、以下の図を見ながら解説します。

![Segment Selector](./images/segment_selector.png)

Intexですが、これはGDTの何番目のディスクリプタを指定するか示すものです。
例えばGDTの1つ目のディスクリプタを指定したかったら、bit[3]を1にします。

Table Indicatorは指定するディスクリプタがGDTかLDT(Local Descriptor Table)かを識別するためのフラグです。
GDTの指定をしましょう。

RPLは特権レベルを指定します。
今はカーネルランドの話をしているので、ここでは0を指定します。

# コードの解説

ここからはコードを見ながらその解説をします。

## GDTを作る

まずはGDTを作ります。

最低限作るべきディスクリプタは

1. Null Descriptor
2. 読み出しと実行が可能な権限0のディスクリプタ
3. 読み出しと書き込みが可能な権限0のディスクリプタ

の3つです。
これらのデータ構造を作るC言語の関数 `make_segment_descriptor` は以下のようになります。

```c
uint64_t make_segment_descriptor(uint32_t type, uint32_t dpl, uint32_t null_flag)
{
    uint64_t segment_descriptor = 0;
    /* baseとlimitは無視されるので0でよい */
    // typeはbit43:41に入れる
    segment_descriptor |= (((uint64_t)type) << 41);
    // dplはbit46:45に入れる
    segment_descriptor |= (((uint64_t)dpl) << 45);
    
    // null_flag == 1でnull descriptor
    if (null_flag == 0) {
        // 他のデフォルト設定
        // G,L,P,S = 1、他は0
        segment_descriptor |= 0x00a0900000000000;
    } else {
        // null descriptorなのですべて0
        segment_descriptor = 0x0000000000000000;
    }

    return segment_descriptor;
}
```

引数にはセグメントの種類を表す `type` と権限を表す `dpl` 、それにNull Descriptorを生成する際に立てる `null_flag` をとります。
ディスクリプタは8バイトなので、戻り値は`uint64_t`とします。

まず変数 `segment_descriptor` を作り、これを加工することで目的のディスクリプタを生成します。

baseとlimitですが、CPUに無視されるので0のままで大丈夫です。
`type` と `dpl` はそれぞれbit43:41とbit46:45の位置に設定します。

`null_flag` が0のときは通常のディスクリプタを作ります。
G,L,P,Sフラグを1にセットし、他は全て0とします。
`0x00a0900000000000`を2進数に直して、表と照らし合わせてみると分かるとおもいます。

`null_flag`が1のときはNull Descriptorを作る。
パラメータ全て0として設定する。

そうして作ったディスクリプタを呼び出し元に返します。

以上の関数を用いてGDTを作成します。

```c
uint64_t *GDT = 0x80;

void init_gdt(void)
{
    // 空, KERNEL_CS, KERNEL_DSの3つを用意
    GDT[0] = make_segment_descriptor(0, 0, 1);
    GDT[1] = make_segment_descriptor(5, 0, 0);
    GDT[2] = make_segment_descriptor(1, 0, 0);
}
```

必要な3つのディスクリプタを生成し、GDTを構築しました。
GDTは空いているメモリスペースを指定してあげます。
自分は `0x80` にしました。何となくです。

## GDTのロード

次はGDTをロードします。

```asm
.global         load_gdt
load_gdt:
    mov     rax,rdi     # 第一引数はbase address
    mov     rcx,rsi     # 第二引数はlimit
    mov     rdx,0x10
    mov     [rdx],cx
    mov     [rdx + 2],rax
    lgdt    [rdx]
    ret
```

GDTのロード命令はアセンブラでしか書けないため、アセンブラで書きます。
GDT自体のbaseとlimitを受け取り、メモリの `0x10` から6バイトの領域で作業します。
リトルエンディアンなことに注意してメモリ上に適切に並べ、 `lgdt` 命令でロードします。

C言語から次のように呼び出します。

```c
void init_gdt(void)
{
    // 空, KERNEL_CS, KERNEL_DSの3つを用意
    GDT[0] = make_segment_descriptor(0, 0, 1);
    GDT[1] = make_segment_descriptor(5, 0, 0);
    GDT[2] = make_segment_descriptor(1, 0, 0);
    load_gdt(GDT, 0x18);
}
```

第一引数に先頭アドレス、第二引数にデータ構造の長さを指定します。

## セグメントを設定する

GDTがロードされたのでセグメントを設定しましょう。

```asm
.global             set_segment_register
set_segment_register:
    cli             # まずは割り込みを禁止

    mov     ax,0x0 # ax = 0x0

# segment register(CS以外)をnull selectorに設定
    mov     ds,ax
    mov     es,ax
    mov     ss,ax
    mov     gs,ax
    mov     fs,ax

# CSの設定にiretq命令を使う
# スタックにSS,RSP,RFLAGS,CS,RIPの順に設定したい値を入れていく
    mov     rcx,rsp
    push    0       # ss = 0に設定
    push    rcx     # rspはそのまま
    pushfq          # RFLAGSはそのまま
    push    rdi     # cs = rdi(第一引数)に設定(権限のみ見る)
    lea     rcx,main_label
    push    rcx  # rip = main_labelのアドレス
    
    iretq           # pushした値をそれぞれに書き込み、main_labelにジャンプ

.global             main_label
main_label:
    sti
    call    main_routine
```

まずは安全のために割り込み禁止命令 `cli` を出します。

次にCS以外のセグメントレジスタを0に設定します。

CSの設定ですが、 `iretq` 命令を使用して設定します。
`iretq` 命令はスタックに積んである8バイトのデータ5つを同時に `pop` し、それぞれのレジスタに割り当てる命令です。
一旦設定したい値をスタックに `push` し、 `iretq` 命令を発行します。
設定は以下の通りです。

- SS = 0
- RSP = RSP(変えない)
- RFLAGS = RFLAGS(変えない)
- CS = {設定したい値}
- RIP = {ジャンプしたいアドレス(`main_label`)}

`lea` 命令はオペランドの実効アドレスを計算する命令です。
本来は `push main_label` でも大丈夫なのですが、自分の環境だと不正な値となったためこのように実効アドレスを計算させています。

`iretq` 命令は `RIP` も指定するので、ここは `main_label` にジャンプするように `main_label` のアドレスを `RIP` に設定します。
このようにすることで、 `iretq` 命令の次は `main_label` からスタートできます。

`main_label` では、まず割り込み禁止を `sti` 命令で解除します。
そして `main_routine` を `call` して処理を移します。
