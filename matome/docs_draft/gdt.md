# GDT

## GDTとは

Global (Segment) Descriptor Tableの略称。

OSのメモリ管理においてセグメンテーションという方式がある。
物理メモリをセグメントと呼ばれる単位に切り分けて管理する方法で、そのセグメントを管理するためのテーブルがGDTである。
x86_64ではセグメンテーションは使われておらず、代わりにページングと呼ばれるメモリ管理方式を用いてメモリを管理している。
じゃあいらないかというとそうでもなく、CPU内部のセグメンテーションを処理する回路を無効にできないため、初期化作業はいまだに必要である。

## セグメンテーションに関連するレジスタ群

- CS, SS, DS, ES, FS, GS
    - セグメントレジスタと呼ばれるレジスタたち。16bit長。
    - GDTにおいては、テーブルの何番目を指すのか、権限レベルはどうなのかといったことを指定するために用いる。
    - 64-bitモードでは扱うのは実質CSのみ
- GDTR
    - GDTのベースアドレスとリミットを指定するレジスタ。64bitモードでは79bit長。

## 64-bitモードのセグメンテーションのフロー

全体像から見よう。以下の図がx64のメモリ管理の概観である。

![segmentation and paging](./images/segmentation_and_paging.png)

ページングと一緒になっているのでややこしいが、ここではセグメンテーションの部分だけ見よう。論理アドレスからリニアアドレスへの変換方法を記す。

まず論理アドレスが与えられると、CPUはセグメントレジスタにセットされているセグメントセレクタを見てGDTの何番目のディスクリプタを見るかを確認する。

次に、指定されたディスクリプタを見て、セグメントがリニアアドレスのどこから始まっているのか、つまりセグメントのベースアドレスを確認する。

そして、論理アドレスはそのセグメントのオフセットとして見られるので、論理アドレスとリニアアドレスの対応は、

```
リニアアドレス = 論理アドレス + セグメントのベースアドレス
```

となる。

具体例を挙げる。

論理アドレスが0x00010000で、現在のセグメントレジスタにセットされているセグメントセレクタのindexが1、GDTの1番目のディスクリプタが表すベースアドレスが0x30000000とする。

この時、まずセグメントセレクタのindexが1なので、GDTの1番目のディスクリプタを見る。GDTの1番目のディスクリプタには0x30000000がベースアドレスとしてセットされているので、ここを基準に見る。

与えられた論理アドレス0x00010000をオフセットとして見るので、上の計算式に当てはめてみると、

```
リニアアドレス = 0x00010000 + 0x30000000
			　= 0x30010000
```

となり、リニアアドレスは0x30010000と分かる。

### GDT 

まずGDTであるが、これは以下のようなビット列が連なったテーブルである。

![segment descriptor](./images/segment_descriptor.png)

重要なのはBaseとSegment Limitである。セグメンテーションではメモリをセグメントという単位で分割するが、Baseというのはそのセグメントが開始するアドレスである。一方Segment Limitというのはそのセグメントの長さである。例えば、Base = 0x7c00, Segment Limit = 0x100とすると、そのセグメントは0x7c00 ～ 0x7d00の範囲である。

その他のパラメータの設定はとりあえずLinuxのを真似ておけば大丈夫だろう。以下設定。

- DとL: D = 0, L = 1で64-bitモードで動作するコードセグメントを表す。
- AVL: OS用のフラグ。Linuxでは0。
- DPL: セグメントへのアクセスに必要な特権レベルを表す。カーネルランドなので0を指定しておく。
- G: limitの単位を表す。0 = byte, 1 = page(4KB)
- P: セグメントがメモリ上に存在するときは1、存在しないときは0に設定する。Linuxでは常に1。
- S: セグメントディスクリプタは1に設定。
- Type: セグメントのタイプを設定する。色々あるが、実行と読み出し可能なコードセグメントの場合は5を設定し、読み書き可能なデータセグメントの場合は1を設定する。

x64ではセグメンテーションが使われていないといったが、これはセグメントの指定を、メモリ全体を指すように設定することで実質無効化するということを言っている。また、Segment Limitは64-bitモードでは無視される。つまり、Base = 0にCPUが強制することによって、メモリ全てを包むセグメントを作り、セグメントではメモリを区切らない(1つに区切るともいえる)ようにしている。

また上の図ですべての要素が0のディスクリプタをNull Descriptorという。

GDTの先頭はNull Descriptorにしておく。またセグメントには権限を設定することができる。この権限は小さいほうが高いので注意。

私たちが最低限用意すべきディスクリプタは以下の3つである。

1. Null Descriptor
2. コードセグメントを表す権限0のディスクリプタ
3. データセグメントを表す権限0のディスクリプタ

Null Descriptorはともかく、なぜコードセグメントとデータセグメントの2つが必要なのだろうか。というのも、今やりたいことはメモリ上のデータの読み書き実行である。そこで権限のフラグを見ると、読み出しと書き込みと実行をひとつのディスクリプタで設定することはできないことが確認できる。3つのことをできるように設定しようとすると、ディスクリプタが2つになってしまうのである。

### セグメントセレクタ

セグメントセレクタとは、16bitのセグメントの識別子である。このデータ構造をセグメントレジスタにセットすることによって、現在のセグメントを定義するセグメントディスクリプタを指定する。この章の最初の図を見るとわかりやすい。

セグメントレジスタであるが、64-bitモードではCSにセグメントセレクタをセットしてセグメントディスクリプタを指定する。CS以外は無効化あるいは0として扱われるので気にしなくてよい。

CSであるが、以下の図を見ながら解説する。

![Segment Selector](./images/segment_selector.png)

Intexであるが、これはGDTのディスクリプタの指定である。例えばGDTの1つ目のディスクリプタを指定したかったら、bit[3]を1にすれば良い。

Table Indicatorは、指定するディスクリプタがGDTかLDTかを識別するためのフラグである。LDTはLocal Descriptor Tableであるが、ここでは気にしなくても良い。

RPLは特権レベルを指定する。今はカーネルランドの話をしているので、ここでは0を指定しておけばいいだろう。

# 設定コードの解説

ここまでで個々の内容は説明したが、ここからは具体的なコードを例示して、その解説をする。

## GDTを作る

まずはGDTを作ってみよう。

最低限作るべきディスクリプタは

1. Null Descriptor
2. 読み出しと実行が可能な権限0のディスクリプタ
3. 読み出しと書き込みが可能な権限0のディスクリプタ

の3つである。これらのデータ構造を作るC言語の関数は以下のとおりである。

```c
uint64_t make_segment_descriptor(uint32_t type, uint32_t dpl, uint32_t null_flag)
{
    uint64_t segment_descriptor = 0;
    /* baseとlimitは無視されるので0でよい */
    // typeはbit43:41に入れる
    segment_descriptor |= (((uint64_t)type) << 41);
    // dplはbit46:45に入れる
    segment_descriptor |= (((uint64_t)dpl) << 45);
    
    // null_flag == 1でnull descriptor
    if (null_flag == 0) {
        // 他のデフォルト設定
        // G,L,P,S = 1、他は0
        segment_descriptor |= 0x00a0900000000000;
    } else {
        // null descriptorなのですべて0
        segment_descriptor = 0x0000000000000000;
    }

    return segment_descriptor;
}
```

`make_segment_descriptor`関数の説明をする。

引数にはセグメントの種類を表す`type`と権限を表す`dpl`、それにNull Descriptorを生成する際に用いる`null_flag`をとる。
引数の型は`uint32_t`としているが、ただの`int`でもいいかもしれない。ディスクリプタは8バイトなので、戻り値は`uint64_t`とする。

まず変数`segment_descriptor`を作り、これを加工することによって目的のディスクリプタを生成しよう。

baseとlimitであるが、CPUに無視されるので0のままでいいだろう。`type`と`dpl`はそれぞれbit43:41とbit46:45の位置に設定する。
`null_flag`が0のときは通常のディスクリプタを作る。G,L,P,Sフラグを1にセットし、他は全て0とする。`0x00a0900000000000`を2進数に直して、表と照らし合わせてみると分かるだろう。
`null_flag`が1のときはNull Descriptorを作る。全て0として設定する。