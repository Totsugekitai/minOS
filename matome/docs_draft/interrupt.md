# 割り込みについて

割り込みとは、現在行っている処理Aを一時中断して別の処理Bを行い、Bが終わったらAの処理を再開させるといった一連の流れを言う。

割り込み信号をCPUが受け取ると、現在行っている処理を中断し、割り込みハンドラと呼ばれる処理が開始される。
割り込みハンドラの処理が終了すると、行っていた処理に続きから復帰して処理を再開させる。

## 割り込みベクタについて

プロセッサによる特別な処理を必要とする割り込みには、ベクタ番号と呼ばれる識別番号が割り当てられる。
このベクター番号は、割り込み記述子テーブル(Interrupt Descriptor Table)のインデックスとして用いられる。

ベクタ番号の範囲は0から255まで。
0から31まではアーキテクチャで定められた割り込みや例外のハンドラを登録する。
アーキテクチャで定められていない番号も存在するが、その場合は使ってはいけない。

32から255まではOS開発者が自由に割り込みハンドラを登録してよいベクタ番号である。
一般的には外部のIOデバイスのために用いられる。

## 外部割込み

外部からの割り込みはCPUのピンもしくはlocal APICと呼ばれるコントローラを通じて受け取られる。
現代のCPUにおいて、プライマリなピンはLINT[1:0]ピンであり、これはlocal APICに接続されている。
local APICが有効な時、LINT[1:0]ピンはAPICのlocal vector table(LVT)を通じてプログラムできる。

local APICが無効な時は、これらのピンはINTRとNMIピンとして設定される。

## ソフトウェア割込み

INT n 命令はソフトウェア内部で割り込みを発生させる。
RFLAGS レジスタの IF フラグではマスクできない。

## Interrupt Descriptor Table(IDT)

IDTは割り込みハンドラを登録するテーブルである。
テーブルの先頭を割り込みベクタ0とし、配列の形で定義してやるとよい。
具体的には以下のようにやるとよいかも。

```
typedef void (*interrupt_handler)(void);
interrupt_handler IDT[256] = {NULL};

IDT[0] = handler0;
IDT[1] = handler1;
IDT[2] = handler2;
IDT[3] = handler3;
.
.
.

```

このテーブルの先頭アドレスを IDTR と呼ばれるレジスタに登録し lidt 命令を発行するとテーブルがロードされ、IDTに登録したハンドラが使われるようになる。

